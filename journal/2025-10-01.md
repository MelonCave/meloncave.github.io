# 2025-10-01

## Sguaba: Type-safe spatial math in Rust

When an outfit like the [German drone defense company](https://en.wikipedia.org/wiki/Helsing_(company)) [Helsing](https://blog.helsing.ai/ai-for-ukraine-recovery-hackathon-eac351a3afad) writes [open source software libraries for systems that HAVE TO handle real-world coordinates](https://github.com/helsing-ai), the question of what coordinate system those coordinates are in, and how they’re represented, comes up a lot. And getting it wrong in even a single place opens the door to disastrous consequences ... especially for geometric guidance or precision positioning systems that use Rust, because those demands of those systems are critical enough that the developers actually NEED the speed of something like Rust, ie ***it's not just a gaming engine***, where close is good enough -- there's just no tolerance for: "So what if it's wrong? YOLO" in this kind of work ... whereas ALMOST ALL of AI is built on the ***"So what if it's wrong? YOLO! We'll overcome everything with more processing power!"***

Toward this end, [Jon Gjengset](https://www.youtube.com/@jonhoo), while working at Helsing, wrote the open-source [crate Sguaba](https://github.com/helsing-ai/sguaba), which is named after the self-navigating boat Sguaba Tuinne ('Wave-sweeper') of the Celtic deity [Manannán mac Lir](https://en.wikipedia.org/wiki/Manann%C3%A1n_mac_Lir) that is navigated solely by the thoughts of its pilot. Squabe must operate in harsh, chaotic environments while preventing all kind of catastrophic coordinate system errors in defense software through Rust's type system, ensuring fighter jets, drones, and battlefield systems never accidentally mix incompatible spatial reference frames (WGS84, ECEF, NED, FRD). This is ensured with type-safety at compile-time rather than algorithmic failure prevention during critical operations.

Thus, [Sguaba is a Rust crate](https://youtu.be/kESBAiTYMoQ?si=nB_WojgFJ9zC4f4u) which is especially worth thinking about and really understanding, strictly because of type safety and error elimination, RATHER than expecting smart processing units to make correct decisions ... only because, sometimes it is necessary to really delve into details like strongly-typed coordinates and vectors with their respective coordinate system and conversions implemented between them ... EVERYBODY, eg CAD jockeys, implicitly assumes *their* coordinate system is anchored at the Center of the Universe and everyone else should standardize on their origin ... some, like AI artists don't care about PRECISE location or actually prefer imprecise fuzziness ...  but PRECISE location is always about WHY location actually matters, ie gravity, and where gravity is goint to put all other references ... *without gravity, you can't locate anything.* 

There are a wide variety of ways to describe the locations of objects in abstract space. To name a few, there is: [World Geodetic System, WGS84 the current standard](https://en.wikipedia.org/wiki/World_Geodetic_System), the well-known Earth-bound system of latitude and longitude; [ECEF (“Earth-centered, Earth-fixed”)](https://en.wikipedia.org/wiki/Earth-centered,_Earth-fixed_coordinate_system), a Cartesian coordinate system fixed to Earth’s axes. A planetary coordinate system (also referred to as planetographic, planetodetic, or planetocentric) is a generalization of the geographic, geodetic, and the geocentric coordinate systems for planets other than Earth. Coordinate systems similiar to the World Geodetic System are defined for other solid celestial bodies, such as in the selenographic coordinates for the Moon.  As with any spatial reference system, ECEF consists of an abstract coordinate system (in this case, a conventional three-dimensional right-handed system), and a geodetic datum that binds the coordinate system to actual locations on the Earth. The ECEF that is used for the Global Positioning System (GPS) is the [geocentric WGS84]((https://en.wikipedia.org/wiki/World_Geodetic_System)), which currently includes its own ellipsoid definition.

Sguaba Rust crate achieves zero-runtime-cost coordinate system safety by encoding five spatial coordinate systems (WGS84, ECEF, NED, FRD, ENU) as compile-time type parameters, preventing coordinate system mixing errors through Rust's type system while maintaining production-grade performance for aerospace applications. Hopefully, the essential nature of type safety is almost intuitively obvious, but what is also immediately apparent is that these coordinate systems can matter ONLY in the orbit of the dominant celestial body [anywhere that another large celestial body or collection of bodies exert a greater gravitational "revelance" on the geometries of movements in that location] ... spatial math in software must be depends upon on inescapable reality, ie Gravity bats last ... *without gravity, you can't locate anything.* 

For example, the ECEF coordinate system has the following parameters:

 * origin at the center of the chosen ellipsoid. In WGS84, this is center of mass of the Earth ... the center of "gravitational relevance" driving the location/placement of all LARGE reference points.
* Z axis is the line between the North and South Poles, with positive values increasing northward. In WGS 84, this is the international reference pole (IRP), which does not exactly coincide with the Earth's rotational axis, The slight "wobbling" of the rotational axis is known as polar motion, and can actually be measured against an ECEF.
* X axis is in the plane of the equator, passing through the origin and extending from 180° longitude (negative) to the prime meridian (positive); in WGS84, this is the IERS Reference Meridian.
* Y axis is also in the plane of the equator, passing through extending from 90°W longitude (negative) to 90°E longitude (positive)

Contemplation of these coodinate system parameters quickly reveals why things are extremely releveant anywhere on Earth like WGS84 cease to be relevant anywhere outside the Earth's outer orbit ... *without gravity, you can't locate anything.* 

# Sguaba: Because coordinate system errors can result in HUGE catastrophic failure

**Helsing AI has open-sourced Sguaba, a Rust crate that prevents coordinate system mix-ups through compile-time type safety—making it nearly impossible to accidentally confuse a drone's body frame with GPS coordinates or mix metric and imperial units.** Created by Jon Gjengset (author of "Rust for Rustaceans") for defense applications where such errors can destroy missions or cost lives, the library represents a paradigm shift from traditional runtime validation to compile-time guarantees. Named after the self-navigating boat of Celtic mythology that responded to its pilot's thoughts alone, Sguaba aims to make spatial mathematics as intuitive and error-proof as that legendary vessel's navigation. The library is already being used at Helsing for systems handling fighter jet orientation, strike drone targeting, and underwater autonomous vehicles—applications where coordinate frame confusion could have "disastrous consequences."

## The Mars Climate Orbiter disaster of 1999

This $327 million lesson in data type safety perfectly encapsulates why coordinate system handling matters. 

NASA's $327.6 million spacecraft burned up in Mars' atmosphere ... *as the experts on engineers watched, double-checked their calculations and made the same error programmed into the software* ... because Lockheed Martin's ground software provided thrust data in pound-force-seconds while NASA's flight software expected newton-seconds—a 4.45× conversion error. The spacecraft approached Mars at 60km altitude instead of the planned 150km and was destroyed. Similarly, in 1991, a Patriot missile system failed to intercept an Iraqi Scud missile in Dhahran, Saudi Arabia, killing 28 U.S. soldiers. After 100 hours of continuous operation, floating-point precision loss accumulated to 0.34 seconds of timing error—causing the system to look 570 meters away from where the missile actually was.

These failures share a common thread: **units and coordinate systems are semantic information that traditional software cannot verify**. Comments and documentation can describe whether a variable represents meters or feet, latitude or ECEF X-coordinates, but the compiler cannot enforce correctness. Enter Sguaba, which leverages Rust's type system to encode coordinate systems as compile-time information, making it literally impossible to compile code that mixes incompatible reference frames.

## How Sguaba makes coordinate confusion a compile error

Sguaba's core innovation is encoding coordinate systems in Rust's type system through two fundamental generic types: `Coordinate<System>` representing points in space, and `Vector<System>` representing displacements or directions. Both are parameterized by a `CoordinateSystem` trait, making them strongly typed to their reference frame. The brilliance lies in what this prevents: you cannot add a coordinate in one system to a coordinate in another without an explicit transformation, and attempting to do so results in a compiler error rather than a runtime bug or silent data corruption.

The library supports five primary coordinate systems essential for aerospace and robotics applications. **WGS84** (World Geodetic System 1984) represents positions using latitude, longitude, and altitude—the familiar GPS coordinate system. **ECEF** (Earth-Centered, Earth-Fixed) uses Cartesian coordinates with origin at Earth's center, rotating with the planet. **NED** (North, East, Down) provides a local coordinate frame where axes point toward the North Pole, perpendicular east, and toward Earth's core. **FRD** (Front, Right, Down) describes positions relative to a vehicle's body—forward along its nose, right perpendicular to that, and down through its belly. Finally, **ENU** (East, North, Up) offers an alternative local frame commonly used for ground vehicles.

The `system!` macro enables users to define custom coordinate systems with specific semantics. You might define `system!(struct PlaneFrd using FRD);` and `system!(struct EmitterFrd using FRD);` to distinguish between your aircraft's body frame and a radar emitter's frame. Even though both follow FRD conventions, they are **distinct types** at compile time. This prevents accidentally treating coordinates from one aircraft as though they belong to another—a subtle error that could cause targeting failures.

Transformations between coordinate systems use `RigidBodyTransform<From, To>`, parameterized by both source and destination systems. A transform from ECEF to a plane's NED frame has type `RigidBodyTransform<Ecef, PlaneNed>`, and the compiler enforces that you can only apply this transform to `Coordinate<Ecef>` values, producing `Coordinate<PlaneNed>` results. Transform composition through the `and_then()` method or multiplication operator is type-checked: the "middle" coordinate system must match, similar to matrix multiplication dimensions. Attempting to chain incompatible transforms—say, applying an ECEF-to-NED transform followed by a FRD-to-ENU transform—fails at compile time because NED ≠ FRD.

## The intentional use of unsafe to enforce semantic correctness

Sguaba takes an unconventional approach to Rust's `unsafe` keyword: certain operations are marked unsafe not because they violate memory safety, but because they assert semantic correctness that the type system cannot verify. Creating a `RigidBodyTransform::new()` requires unsafe because you're asserting that the translation vector and rotation matrix are mathematically correct for converting between the specified coordinate systems. Constructing `RigidBodyTransform::ecef_to_ned_at()` requires unsafe because you're asserting that the provided WGS84 position truly represents the origin of your NED system. The operation `Pose::map_as_zero_in()` requires unsafe because you're claiming a pose represents a coordinate system's origin.

These unsafe blocks serve as **explicit markers forcing conscious verification**. Traditional coordinate system libraries make every operation equally "unsafe" in the semantic sense—you could mix up coordinate systems anywhere. Sguaba's design means that if your code compiles and you haven't written unsafe blocks, you mathematically cannot have coordinate system mix-ups. The unsafe blocks document exactly where human judgment is required, acting as checkpoints for code review and verification.

The type safety is completely zero-overhead: coordinate system types are zero-sized phantom type parameters that exist only at compile time. At runtime, a `Coordinate<PlaneFrd>` and `Coordinate<PlaneNed>` have identical memory layout—just three floating-point values. The safety guarantees cost nothing in execution time or memory.

## Jon Gjengset: from MIT distributed systems to defense software

Jon Ferdinand Ronge Gjengset brings exceptional expertise to creating Sguaba. He earned his PhD in Electrical Engineering and Computer Science from MIT in 2021, working in the Parallel and Distributed Operating Systems group under Professor Robert Morris. His dissertation, "Partial State in Dataflow-Based Materialized Views," led to Noria, a database system designed for high-performance incremental view maintenance—work that won the SOSP Student Research Competition in 2017.

Before joining Helsing in August 2023 as Principal Engineer, Jon held positions at AWS maintaining Rust build infrastructure and co-founded ReadySet, a commercial database system based on his PhD research. But he's perhaps best known in the Rust community as the author of "Rust for Rustaceans" (No Starch Press, 2021), the definitive intermediate-to-advanced Rust programming text. His YouTube channel features live coding sessions teaching complex Rust concepts—async/await, pinning, variance, atomics—making advanced systems programming accessible to thousands of developers.

Jon initially approached Helsing with skepticism about working in defense. He was convinced by the mission to modernize European defense posture and recognized that the technical challenges aligned perfectly with his expertise. As he described it: "The entire domain is essentially a giant distributed systems problem where robust, efficient, secure, low latency solutions are critical." He noted that for systems running on Eurofighters, quadcopters, or autonomous submarines operating for months without service, "You're not running Python there... You could write it in C, but it's extremely risky."

## Helsing's mission makes coordinate system safety existential

Helsing was founded in 2021 by Torsten Reil (founder of NaturalMotion), Dr. Gundbert Scherf (former McKinsey Partner and advisor to Germany's Federal Ministry of Defense), and Niklas Köhler (AI/ML expert) with an explicit mission: "Artificial intelligence to protect our democracies." The company develops AI-powered defense systems across multiple domains and has achieved remarkable scale—valued at approximately €5 billion as of July 2024, with partnerships spanning Saab, Airbus, and Rheinmetall.

Their **HX-2 strike drones** are AI-enabled precision munitions with up to 100km range, capable of operating in electronic warfare environments. With over 10,000 units ordered for Ukraine, Helsing has become one of the largest strike drone manufacturers globally. The **CA-1 Europa** autonomous combat drone, unveiled in September 2025, serves as a "loyal wingman" alongside crewed aircraft using the Centaur AI agent for autonomous flight. The **Altra platform** enables reconnaissance-strike operations with multiple drones controlled by single operators, and they've tested the **Centaur AI** as an autonomous fighter jet pilot in real combat scenarios with Saab Gripen aircraft.

For these systems, coordinate frame confusion isn't an academic concern—it's life-or-death. A strike drone must convert target coordinates from a ground station's NED frame to its own FRD body frame for weapon release calculations. Swarm operations require multiple drones to share a consistent coordinate frame for coordination. The Centaur AI pilot must fuse radar returns, sensor data, and navigation information, each potentially in different reference frames, to make split-second decisions. Electronic warfare resistance means drones must autonomously navigate without GPS, relying entirely on internal coordinate calculations.

As Helsing's blog post on Sguaba states: "When we write software for systems that have to handle real-world coordinates, the question of what coordinate system those coordinates are in, and how they're represented, comes up a lot. And getting it wrong in even a single place opens the door to disastrous consequences."

Helsing uses Rust extensively—Jon reports approximately 50% of the codebase is Rust-native with the remainder being migrated. Rust is used for backends, embedded systems, and core infrastructure. Only web frontends (TypeScript) and some ML orchestration (Python) use other languages. The company became a Rust Foundation Silver Member in August 2023, reflecting their commitment to the language and ecosystem.

## Sguaba Tuinne: the wave-sweeper that thinks its own course

The name Sguaba (pronounced from Celtic mythology "Sguaba Tuinne" meaning "Wave-sweeper") comes from the self-navigating boat of Manannán mac Lir, the Celtic deity of the sea and guardian of the otherworld. In Irish mythology, this legendary vessel was navigated solely by the thoughts of its pilot—no rudder, no sails, just intention translating directly to motion. The boat knew where to go and how to get there without the pilot needing to understand the mechanics of navigation.

This serves as a perfect metaphor for Sguaba's design philosophy. Just as the mythical boat prevented navigation errors by making the pilot's intent directly actionable, Sguaba prevents coordinate system errors by making the programmer's intent (this coordinate is in FRD, that one is in NED) directly enforceable by the compiler. The pilot of Sguaba Tuinne didn't need to worry about winds, currents, or steering—the boat handled the navigation complexity. Similarly, engineers using Sguaba don't need to manually track coordinate systems or remember to apply the right conversions—the type system handles that complexity automatically.

The choice of name reflects both the library's purpose (making spatial navigation safe and intuitive) and its cultural context (developed by a Norwegian engineer working for a pan-European defense company). It's also characteristic of Jon Gjengset's approach to API design: thoughtful, pedagogical, and emphasizing that good tools should reduce cognitive load rather than adding to it.

## Why coordinate systems exist only in gravitational fields

The statement "without gravity, you can't locate anything" reflects a fundamental truth about coordinate systems: they require physical reference points, and in space, those reference points are gravitational bodies. Every coordinate system needs a defined origin, and in three-dimensional space, meaningful origins are the centers of mass of gravitational bodies. Position is inherently relative—you cannot specify an absolute location in the universe, only a location relative to some chosen reference.

Coordinate systems exist in a hierarchy based on gravitational dominance. At the galactic scale, we use galactic coordinates. For the solar system, we use **barycentric coordinates** with origin at the solar system's center of mass. For planetary motion, **heliocentric coordinates** place the Sun at the origin. For satellites, **geocentric coordinates** (ECI, ECEF) use Earth's center. For local operations, **topocentric frames** (NED, ENU) are centered on surface points. Each level is appropriate for its domain of gravitational influence.

WGS84 and ECEF are explicitly tied to Earth's gravitational field. WGS84's defining parameters include the geocentric gravitational constant (GM = 3.986004418 × 10¹⁴ m³/s²) and Earth's mean angular velocity. The ellipsoid shape itself results from Earth's rotation and gravitational field creating an oblate spheroid. The Z-axis points along Earth's rotation axis, which is defined by the planet's angular momentum—a direct consequence of its gravitational collapse and rotation.

For other planets, we define **planetocentric coordinate systems** with origins at their centers of mass. Mars has areocentric coordinates, the Moon has selenocentric coordinates, and so on. Each uses that body's gravitational center as the reference point. The choice of coordinate system depends on which gravitational body dominates: if you're in low Earth orbit, geocentric systems make sense; if you're traveling between planets, heliocentric or barycentric systems are more appropriate; if you're operating on Mars' surface, areocentric systems become relevant.

This is why Sguaba's focus on Earth-bound systems (WGS84, ECEF, NED, FRD, ENU) makes sense for aerospace applications within Earth's sphere of influence. The documentation notes that ECI (Earth-Centered Inertial) is missing but could be added—that would extend the library to handle satellite orbital mechanics where an inertial (non-rotating) Earth-centered frame is essential. Each coordinate system represents a different way of describing position relative to Earth's gravitational center or local surface.

## The mathematical complexity behind coordinate conversions

Converting between coordinate systems is mathematically non-trivial, which is why libraries like Sguaba matter. Consider the seemingly simple conversion between WGS84 (latitude, longitude, altitude) and ECEF (X, Y, Z). The forward direction—WGS84 to ECEF—is straightforward: you calculate X-Y-Z coordinates for the latitude-longitude point on the ellipsoid surface, then add a perpendicular vector for height above the ellipsoid. But the reverse conversion is significantly harder: **no closed formula exists** for extracting latitude and height from X-Y-Z coordinates. Bowring's formula (1976) provides an iterative method that converges to accuracy within 10⁻¹¹ degrees for points within 10,000 meters above or 5,000 meters below the ellipsoid, but even that first iteration requires careful numerical implementation.

High-latitude navigation presents particular challenges. Near the poles (above about 67°N/S), meridians converge rapidly, causing small position errors to produce very large heading errors. At 85° latitude, the error magnification is approximately 10¹⁷ times larger than at low latitudes. This is why polar navigation often switches to alternative coordinate systems—equatorial coordinates where the computational north pole lies in the equatorial plane, avoiding singularities.

Planetocentric versus planetographic coordinates create subtle but consequential differences. For Mars, these two systems differ by up to 0.34° in latitude and 2 kilometers in altitude due to the planet's oblateness. NASA's MAVEN mission uses planetographic coordinates, while older missions used planetocentric, leading to potential 25% errors in atmospheric density comparisons and 12% errors in thermospheric density studies when data are compared without accounting for the coordinate system difference.

Time-dependent reference frames add another layer of complexity. Earth's rotation axis wobbles (polar motion), and precession and nutation change the orientation of the equator and equinox over time. This means coordinate systems must specify an epoch—J2000 (mean equator and equinox at 12:00 TT on January 1, 2000) and B1950 are common standards. The FK4/FK5 precession models accumulate errors of less than 0.1 arcseconds within 40 years but grow to about 1 arcsecond over 360 years, which matters for long-term astronomical calculations.

## How Sguaba compares to the coordinate system ecosystem

Sguaba occupies a unique niche in the coordinate system library landscape. Most existing solutions—PROJ, GDAL/OGR, pyproj, GeoTools—prioritize comprehensive coverage of coordinate reference systems (thousands of EPSG codes) with runtime validation. They use string-based CRS identification like "EPSG:4326" for WGS84, meaning all coordinates share the same underlying type (usually just arrays of floats) regardless of which coordinate system they represent. The validation happens at runtime if it happens at all, making it easy to accidentally pass NED coordinates to a function expecting ECEF coordinates.

In the Rust ecosystem, the **proj crate** provides high-level bindings to the C library PROJ, supporting thousands of coordinate systems but offering no compile-time safety—coordinates are generic tuples regardless of CRS. The **jord crate** focuses on geodetic calculations using n-vectors and provides some type differentiation (`GeodeticPosition`, `LocalFrame`) but lacks compile-time coordinate system validation. The **geo crate** (part of GeoRust) is widely used for geometric primitives and algorithms but its `Coordinate<T>` struct is generic only over numeric type, not coordinate system. Traditional transformation libraries like **coord_transforms** and **map_3d** use pure function-based APIs where all coordinates are `Vector3<f64>`, providing zero type safety.

The closest analogy to Sguaba's approach exists in experimental C++ libraries like "Typesafe Coordinate Systems" (KlasMvW/typesafe_coordinate_systems on GitHub), which uses template metaprogramming for compile-time coordinate system trees. However, C++'s template machinery is notoriously complex, and such libraries have seen limited adoption. Sguaba benefits from Rust's more ergonomic trait system and zero-sized types, making the compile-time machinery less invasive.

Research on type-safe coordinate systems exists in other domains. A 2022 paper (arXiv:2209.06603) explored type-safe genomic coordinate systems in Rust, OCaml, and Python to prevent off-by-one errors from coordinate confusion in bioinformatics—similar motivation, different domain. But in mainstream GIS and aerospace libraries, runtime validation remains universal.

Why is type safety so rare? Several factors contribute: most libraries predate modern type system capabilities; C and Python (dominant languages in GIS) lack the necessary type features; the GIS community prioritizes comprehensive CRS support over type safety since applications often need to handle coordinate systems determined at runtime from file metadata; and there's combinatorial complexity in supporting N coordinate systems with type safety (potentially N² transformation implementations).

Sguaba makes the opposite trade-off: **limited built-in systems with strong compile-time guarantees over comprehensive runtime flexibility**. It cannot handle dynamically-determined coordinate systems from file metadata, which makes it unsuitable for general GIS workflows. But for aerospace, robotics, and autonomous systems where coordinate frames are known at compile time and errors could be catastrophic, the trade-off is worthwhile. As one Hacker News commenter noted: "I guarantee this will save you from so many headache causing bugs."

## Precision requirements make type safety non-negotiable

Modern military targeting requires exceptional coordinate precision. The Circular Error Probable (CEP) standard demands that coordinates be specified to thousandths of an arc second, and differential GPS (DGPS) with Real-Time Kinematic (RTK) corrections achieves centimeter-level accuracy (±1-2cm) compared to standard GPS's ±1-3 meter accuracy. For drone defense specifically, systems must achieve sub-second decision-making for intercept calculations, continuously transform coordinates between radar, sensor, and weapon reference frames, and predict drone trajectories accounting for velocity, acceleration, and maneuverability—all while potentially operating in electronic warfare environments without external GPS signals.

Helsing's systems must handle multiple domains simultaneously. The CA-1 Europa autonomous aircraft operates in the air domain, HX-2 drones conduct strikes, ground stations coordinate operations, satellites (via partnership with Loft Orbital) provide reconnaissance from space, and SG-1 Fathom autonomous underwater vehicles operate subsurface. Each domain traditionally uses different coordinate conventions: aviation uses FRD body frames, satellites use ECI or ECEF, ground systems often use local NED or ENU frames, and underwater vehicles may use different conventions still. Robust transformation libraries like Sguaba become essential for fusing data across these domains.

The consequences of coordinate errors in these applications cannot be overstated. A weapon released with coordinates in the wrong reference frame could miss its target by kilometers. A drone swarm with inconsistent coordinate frames could collide with each other or friendly aircraft. An intercept calculation mixing coordinate systems could fail to stop an incoming threat. The Patriot missile failure in 1991 demonstrates this: a 0.34-second timing error translated to 570 meters of spatial error for a missile traveling at 1,676 m/s, causing complete tracking failure.

Type safety addresses this by providing mathematical proof of correctness. If your Rust code compiles with Sguaba and you haven't written unsafe blocks, you have formal verification that coordinates are always used in their correct reference frames. This isn't just good practice—it's a safety requirement for critical systems. As Jon Gjengset noted when discussing Helsing's technology choices: "Sometimes even small decisions can have a huge impact on what actually happens in the real world."

## The engineering philosophy behind hard-to-misuse APIs

Sguaba embodies a specific design philosophy that Jon Gjengset articulated in the library's announcement: making software "hard to misuse" rather than relying on developer discipline. Traditional approaches to coordinate systems assume developers will read documentation carefully, remember which coordinate system each variable uses, and manually apply the correct transformations. This assumption fails under real-world conditions: tight deadlines, team turnover, code refactoring, integration of third-party code, and simple human error.

The library provides two complementary APIs to serve different users. The **engineering-focused API** offers `Pose` and `Orientation` abstractions that match how aerospace engineers think about problems: an aircraft has a pose (position + orientation) in a reference frame, and you want to transform that pose into another frame. The **mathematics-focused API** provides pure `RigidBodyTransform` and `Rotation` types for users comfortable with linear algebra notation. Both APIs share the same type-safety guarantees, but the engineering API adds semantic convenience methods like `Pose::map_as_zero_in()` to express common operations intuitively.

The library's extensive documentation includes not just API references but explanations of coordinate system theory with Wikipedia links for mathematical concepts. Examples demonstrate real-world scenarios like the "plane observation problem": given a plane's position and orientation, plus the bearing and elevation to a detected emitter, calculate the emitter's position in the plane's coordinate frame. These examples help users understand not just *how* to use the API but *why* the design choices make sense.

The use of unsafe for semantic assertions rather than memory safety is perhaps the most philosophically distinctive choice. By marking coordinate system construction as unsafe, Sguaba forces developers to explicitly acknowledge when they're asserting semantic correctness that the compiler cannot verify. This transforms implicit assumptions into explicit code—making reviews easier, documentation clearer, and bugs more visible. It's a recognition that not all correctness properties can be mechanically verified, but we can at least mark the boundaries where human judgment is required.

## Looking forward: the future of type-safe spatial computing

Sguaba's release in 2024 and rapid evolution to version 0.9.5 by 2025 suggests strong internal use at Helsing driving development. The documentation acknowledges missing features: ECI (Earth-Centered Inertial) coordinate system for orbital mechanics, more in-depth documentation with graphics, and additional test coverage. The library is open to community contributions, with Jon Gjengset actively engaging on social media (Fosstodon, Bluesky) and encouraging experience reports.

The broader significance extends beyond Sguaba itself. As autonomous systems, AI-driven decision-making, and swarm coordination become central to modern defense and robotics, the mathematical foundations of coordinate system handling become increasingly critical. The traditional approach—runtime validation and developer discipline—scales poorly as systems grow more complex. Type-safe approaches like Sguaba demonstrate that modern programming languages can encode domain invariants that were previously only documented in comments or standards.

This has implications beyond defense. Aviation systems, space exploration, autonomous vehicles, robotics, surveying, and even augmented reality applications all deal with multiple coordinate frames. The lessons from Sguaba—encode coordinate systems in types, make invalid states unrepresentable, use unsafe markers for semantic boundaries—could translate to any domain where coordinate confusion causes problems.

The combination of historical disasters (Mars Climate Orbiter, Patriot missile), modern precision requirements, and the complexity of multi-domain operations makes coordinate system safety one of the most critical yet often overlooked aspects of spatial computing. Sguaba demonstrates that we can do better than hoping developers remember which coordinate system each variable uses. By leveraging Rust's type system, we can make coordinate system correctness a compiler guarantee rather than a runtime hope—transforming an entire class of potentially catastrophic bugs into compile errors that never make it to production.

As Jon Gjengset announced when open-sourcing the library: "If you've ever had to deal with coordinate systems and rigid body transforms, Sguaba will hopefully make your life slightly less painful." For systems where coordinate errors could destroy spacecraft, down aircraft, or cost lives, that understatement captures something profound: the best way to prevent disasters is to make them literally impossible to express in code.