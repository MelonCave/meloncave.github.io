# 2025-09-09

## Rust For PKM Dev; Setting Up The mdBook Repository

In the first module of [Phase I](src/1.Projects/PhaseI), today's scope is strictly only **repository CREATION, to initialize our PKM Project** with an [mdBook](https://rust-lang.github.io/mdBook/) clone on GitHub at [https://github.com/AncientGuy/PKM](https://github.com/AncientGuy/PKM).

The foundation begins with a new GitHub repository, cloned from a working [**mdBook** repository](https://github.com/rust-lang/mdBook); in other words, the first day, AT LEAST, is spent getting comfortable, not only with all of the [**mdBook** Documentation](https://rust-lang.github.io/mdBook/), but also with setting up a working Rust lang environment on one's home machine and getting comfortable with the Rust ecosystem. There is no way to accomplish this in only one day, but it should be understood that **mdBook** and the customization and modifications of the Rust code will be a part of every following day of this 100-day personal knowledge management (PKM) system building adventure.

This repository will house the entire Personal Knowledge Management (PKM) system, after tomorrow including atomic notes in Markdown, automation scripts, configuration files, and the mdBook source. Initializing the repository with a README.md file, [a .gitignore file](https://github.com/groda/the_ultimate_gitignore_guide) (configured for Python, Node.js, and Rust build artifacts), and a clear directory structure (/notes, /scripts, /book\_src) is the first task. **At first**, the new repository is configured as an mdBook repository for containing content that is [published using a custom GitHub Actions workflow](https://docs.github.com/en/pages/getting-started-with-github-pages/configuring-a-publishing-source-for-your-github-pages-site#publishing-with-a-custom-github-actions-workflow) directly from that repository, which is conveniently part of the [GitHub Pages feature for hosting static website for [non-business use by] developers](https://docs.github.com/en/pages).

The reason for using [mdBook](https://rust-lang.github.io/mdBook/) at first, as an open source foundation of our PKM project, is that we want to eventually develop proficiency in the use of mdBook specifically because of the Rust language that mdBook is written in. We seek a deep enough proficience so that that we can seriously, realistically [entertain thoughts of of contributing to mdBook](https://github.com/rust-lang/mdBook/blob/master/CONTRIBUTING.md) in ways that it is currently insufficient.  However, mdBook is already plenty sufficient for our purposes as a learning scaffold, so, we are ***not yet*** sure of even how it's not quite sufficient, thus we are not committing to that objective ... but *implicit in the task of setting up this repository is about* ***the BEGINNING*** *of thinking through the cognitive and machine-assisted processes of sorting, sifting, prioritizing and generally improving workflows in the representation of knowledge ... focusing on interests or topics that we care about, as material for specific workflows that might be especially useful ... but the general push of this is not on the specific topics, but rather on knowledge engineering toolchains and methods that will characterize the intelligence gathering side of this PKM, ie the immediate REASON for this work is not about Rust or PKE, but rather about leveling up the PKM game is improving the structure of personal intelligence gathering*.  

The reason for us being unsure is that me may ultimately end up going in a more *Pythonic* direction, because of how large Python is in AI or machine learning applications like Jupyter Notebooks. That would take us into territories that similar to the approach taken by the Modular Platform and Mojo language which is designed to integrate seamlessly with the Python ecosystem. Mojo is like Rust in that both are performance-oriented languages featuring [ownership](https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html) models and a [borrow checker](https://doc.rust-lang.org/1.8.0/book/references-and-borrowing.html), but Mojo is designed for the AI ecosystem and integrates with Python, whereas Rust is a general-purpose systems programming language. Mojo boasts ***the potential*** for higher performance, especially for AI tasks, by using the [Multi-Level Intermediate Representation (MLIR) compiler infrastructure](https://www.modular.com/blog/democratizing-ai-compute-part-8-what-about-the-mlir-compiler-infrastructure) (which is built as a sub-project of the [Low Level Virtual Machine (LLVM) compiler infrastructure](https://github.com/llvm/llvm-project)). Rust is ***currently*** a more mature, stable, and production-ready language with a more complete feature set. The Rust compiler, rustc, primarily utilizes the LLVM compiler infrastructure as its backend for code generation and optimization. rustc performs its own high-level and mid-level optimizations as it translates the Rust code into LLVM Intermediate Representation (IR), which LLVM then processes to generate machine code. MLIR is a more recent sub-project within the LLVM ecosystem designed to address the limitations of LLVM IR for specific domains like high-performance computing and machine learning. MLIR's key features, such as its multi-level nature and support for custom dialects, allow for better representation and optimization of domain-specific operations at higher levels of abstraction before eventually lowering to LLVM IR. We may ultimately move this project to Mojo, perhaps not until the Personal Knowledge Engineering stage.

At first during the slightly more basic or manual Personal Knowledge Mgmt (PKM) stage, we will use [mdBook, a command line tool that creates books using notes written in Markdown](https://rust-lang.github.io/mdBook/). It's simpler to work with Markdown notes starting out, but our real motive is understanding how humans express ideas to machines. That means becoming proficient enough in Rust langauge idioms [to better appreciate what the rustc Rust compiler does and what a multi-level approach like Mojo's MLIR might offer], beyond [understanding the basics of the Rust language](https://github.com/rust-lang/rustlings/) and the [mdBook dev community and mdBook ***issues***](https://github.com/rust-lang/mdBook/issues) including things like the [Rust playground](https://play.rust-lang.org/?version=stable&mode=debug) and just generally delving in to different parts of [the Rust language dev community](https://github.com/rust-lang/). 

At a minimum, getting familiar with Rust and the dev community means proficiency in the [rustup toolchain installer](https://github.com/rust-lang/rustup) beyond just using [rustup update](https://rust-lang.github.io/rustup/basics.html#keeping-rustup-up-to-date) as well as all of the tools that rustup manages such as the [rustc Rust compiler](https://github.com/rust-lang/rustc-dev-guide), Rust's [cargo build tool/package manager](https://doc.rust-lang.org/cargo/) and [crates.io](https://github.com/rust-lang/crates.io), Rust [rust-std standard library](https://doc.rust-lang.org/std/), rust-docs local copies of the Rust documentation, [rustfmt](https://rustprojectprimer.com/checks/formatting.html) and [Abstract Syntax Tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree) and tools like [AST-GREP](https://ast-grep.github.io/) for automatically formatting Rust code according to community standards or to better understand code, [rust-analyzer](https://rust-analyzer.github.io/book/) and the [language server protocol](https://microsoft.github.io/language-server-protocol/) for code completion and refactoring by for IDE extensions and editors, and especially the [Clippy code analyser/linter detecting mistakes](https://doc.rust-lang.org/clippy/).